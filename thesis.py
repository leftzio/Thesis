# -*- coding: utf-8 -*-
"""Thesis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VXFgKlLKifM_lk3Dblkz2vgVA3y10dO8

##GAME
"""

import numpy as np

class ChessGame():  

    #THIS BELONGS IN CHESSGAME CLASS  
    pieces =   {-6:"bking",
                -5:"bqueen",
                -4:"brook", 
                -3:"bbishop",
                -2:"bknight",
                -1:"bpawn",
                 0:"-",
                1:"wpawn",
                2:"wknight",
                3:"wbishop",
                4:"wrook",
                5:"wqueen",
                6:"wking" }

    def __init__(self): 
        self.n =8
        self.board = Board(self.n) 
        self.progress = 0 
        self.rep = 0 
        self.direction = 1 
        self.moves = 0         
        
        self.en_passant = []

        #dict for counting the number a position has been  reached 
        self.posCounter = {} 
        
        #starting position 
        self.posCounter[self.stringRepresentation(self.board.pieces)] = 1
        

    def getInitBoard(self):  # return initial board (numpy board)         
        b=Board(self.n) 
        return  np.array(b.pieces)
        

    def revertBoard(self): 

        self.board = Board(self.n) # ??? 

        self.progress=0
        self.rep=0
        self.direction=1
        self.moves=0

        self.en_passant = []

        #dict for counting the number a position has been reached
        self.posCounter = {}
        #starting position
        self.posCounter[self.stringRepresentation(self.board.pieces)] = 1
        


    def getBoardSize(self):
        # (a,b) tuple
        return (self.n, self.n)

    def getActionSize(self):
        size = (64*64) # maybe add castling etc (+74)
        return size
   
    def getValidMoves(self, board, player):
        b = Board(self.n)
        b.pieces = np.copy(board)
        # for i in range(8):
        #     for j in range(8):
        #         if b.pieces[i][j] == 6:
        #             b.wking = (i,j)
        #         elif b.pieces[i][j] == -6:
        #             b.bking = (i,j)
                
        b.direction_CURR=player

        legalMoves =  b.get_legal_moves(player, self.direction) #(old_pos, new_pos)
        size = self.getActionSize()
        valids = np.zeros((64, 64))
        moves = [x for x in legalMoves if not b.is_in_check(x[0],x[1],player,-self.direction)]

        #en passant list is list of touples (x,y)
        #the first item is the square the pawn will land
        if len(self.en_passant)>0:
            target = self.en_passant[0] #where the pawn will go 
            new = ([b.chess_map_from_index_to_alpha[target[1]], str(target[0] + 1)])
            
            for i in range(1,len(en_passant)):
                old = ([b.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)])

                if b.is_in_check(old,new,player,-self.direction,en_passant=True) == False:
                    moves.append(i,target)
            
        for old, new in moves:
            row = int(old[1]) - 1
            column = b.chess_map_from_alpha_to_index[old[0]]
            old = (row, column)
            
            row = int(new[1]) - 1
            column = b.chess_map_from_alpha_to_index[new[0]]
            new = (row, column)

            valids[8*old[0] + old[1]][8*new[0] + new[1]] = 1


        # #!!!add castling and underpromotions!!!
        # padding = np.zeros(74)

        # return np.append(valids.flatten(),padding)
        return valids.flatten()

    
    def getGameEnded(self,board,player):
        # return 0 if not ended, 1 if player 1 won, -1 if player 1 lost
        
        b = Board(self.n)
        b.pieces = np.copy(board)

        #--------------------------------------
        #These checks also happen in MCTS.search()
        
        #3-fold repetition draw
        stringB = self.stringRepresentation(b.pieces)
        if stringB in self.posCounter:
            if self.posCounter[stringB] >= 3:
               
                # print(stringB)
                # print(f'{self.posCounter[stringB]} -> number')
                return 1e-4

        #progress (pawn moves)
        if self.progress >= 50:
            # draw has a very little value 
            
            return 1e-4
            
        #--------------------------------------



        b.direction_CURR=player

        #insufficient material
        if b.insufficientMaterial():
            # draw has a very little value 
            return 1e-4

        #if opponent is in check
        if b.is_in_check_now(-player, self.direction): 
           
            return player

        if b.has_legal_moves(player, self.direction):
            return 0
        else:
            if b.is_in_check_now(player, -self.direction): 
                
                return -player
            else:
                #stalemate
                # draw has a very little value 
                return 1e-4
        


    def getNextState(self, board, player, action):
        # return next (board,player)
        # action must be a valid move

        self.progress += 1
        self.moves += 1

        b = Board(self.n)
        b.pieces = np.copy(board)

      
        b.direction_CURR=-player
        old, new = np.unravel_index(action, (64,64))

        x_old, y_old = np.unravel_index(old, (8,8))
        x_new, y_new = np.unravel_index(new, (8,8))

        # capture
        if b[x_old][y_old] * b[x_new][y_new] < 0:
            self.progress = 0
        
        # pawn move
        if b[x_old][y_old] == 1 or b[x_old][y_old] == -1:
            self.progress = 0



        if b[x_new][y_new] == 6 or b[x_new][y_new] == -6:
            print("--------------------------------")
            print("ERROR! KING CAPTURE!")
            print(b.pieces)
            print(x_old,y_old)
            print(x_new,y_new)

            assert(False)


        old = b.chess_map_from_index_to_alpha[y_old] + str(x_old+1)
        new = b.chess_map_from_index_to_alpha[y_new] + str(x_new+1)

        en_passant_flag = False
        #en passant move 
        if b[x_old][y_old] == 1 or b[x_old][y_old] == -1:
            if abs(x_old-x_new) == 1 and abs(y_old-y_new) == 1 and b[x_new][y_new] == 0:
                en_passant_flag = True

        b.execute_move(old, new, en_passant_flag)
       
        self.direction = - self.direction

        self.en_passant = []
        if b[x_old][y_old] == 1 or b[x_old][y_old] == -1:
            self.en_passant.append( (x_old+x_new)/2, y_new )
            if abs(x_old - x_new) == 2:
                if y_new+1 < 8:
                    self.en_passant.append(x_new,y_new+1)
                if y_new-1 > 0:
                    self.en_passant.append(x_new,y_new-1)


        stringB = self.stringRepresentation(self.getCanonicalForm(b.pieces,player))
        if stringB in self.posCounter:
            self.posCounter[stringB] += 1
        else:
            self.posCounter[stringB] = 1

        return (b.pieces, -player)


    def stringRepresentation(self, board):
        return str(np.array(board))

    def getCanonicalForm(self, board, player):
        # return state if player==1, else return -state if player==-1
        return player*board

    def getSymmetries(self, board, pi):

        assert(len(pi) == 64*64)

        return [(board, list(pi))]

        # # mirror, rotational        
        # pi_board = np.reshape(pi, (64, 64))
        # l = []
        # for i in range(1, 5):
        #     for j in [True, False]:
        #         newB = np.rot90(board, i)
        #         newPi = np.rot90(pi_board, i)
        #         if j:
        #             newB = np.fliplr(newB)
        #             newPi = np.fliplr(newPi)
        #         l += [(newB, list(newPi.ravel()))]
        # return l

"""##BOARD"""

def in_board(x,y):
        if x>7 or x<0 or y>7 or y<0:
            return False
        return True

class Board():

    # list of all 8 directions on the board, as (x,y) offsets
    # __directions = [(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1),(0,1)]

    def __init__(self, n):
        "Set up initial board configuration."

        self.pieces = [[0 for x in range(8)] for y in range(8)]
        self.bking = (7,4)
        self.wking = (0,4)
        self.direction_CURR=1
        self.direction_temp=1
        
        #setup the initial board
        for i in range(8):
            self.pieces[1][i] = 1
            self.pieces[6][i] = -1

        self.pieces[0][0] = 4
        self.pieces[0][1] = 2
        self.pieces[0][2] = 3
        self.pieces[0][3] = 5
        self.pieces[0][4] = 6
        self.pieces[0][5] = 3
        self.pieces[0][6] = 2
        self.pieces[0][7] = 4

        self.pieces[7][0] = -4
        self.pieces[7][1] = -2
        self.pieces[7][2] = -3
        self.pieces[7][3] = -5
        self.pieces[7][4] = -6
        self.pieces[7][5] = -3
        self.pieces[7][6] = -2
        self.pieces[7][7] = -4

        self.chess_map_from_alpha_to_index = {
            "a" : 0,
            "b" : 1,
            "c" : 2,
            "d" : 3,
            "e" : 4,
            "f" : 5,
            "g" : 6,
            "h" : 7
        }

        self.chess_map_from_index_to_alpha = {
            0: "a",
            1: "b",
            2: "c",
            3: "d",
            4: "e",
            5: "f",
            6: "g",
            7: "h"
        }

    # add [][] indexer syntax to the Board
    def __getitem__(self, index): 
        return self.pieces[index]

    def countDiff(self, color):
        """Counts the difference in material in the game"""
        # count = 0
        # for y in range(self.n):
        #     for x in range(self.n):
        #         if self[x][y]==color:
        #             count += 1
        #         if self[x][y]==-color:
        #             count -= 1
        # return count
    
    

    def get_legal_moves(self, color, direction):
        """Returns all the legal moves for the given color.
        (1 for white, -1 for black
        """
        moves = set()  # stores the legal moves.
        
        # Get all the squares with pieces of the given color.
        for y in range(8):
            for x in range(8):
                
                # if self[x][y] == 6:
                #     self.wking = x,y
                # elif self[x][y] == -6:
                #     self.bking = x,y

                if self[x][y]*color > 0:       #if this square is the same color as the player
                    newmoves = self.get_moves_for_square((x,y), direction)
                    moves.update(newmoves)
                 
        return list(moves)

    def has_legal_moves(self, color, direction):

        moves = self.get_legal_moves(color, direction)
        valids = [x for x in moves if not self.is_in_check(x[0],x[1],color,-direction)]

        return len(valids)>0
    
    def get_type(self, x, y):
        if self[x][y] > 0:
            color = 1
        elif self[x][y] < 0:
            color = -1
        else:
        # skip empty source squares.
            return None,None

        piecetype = self[x][y] * color

        return piecetype, color

    def printBoard(self):
        for x in range(8):
            top = ' '
            for y in range(8):
                if str(self[x][y])[0] == '-':
                    top = top[:-1]
                top+=str(self[x][y])
                top+="        "
            print(top)
        print("\n\n")
    



    def getRookMoves(self, pos,color):
        column, row = list(pos.strip().lower())
        row = int(row) - 1
        column = self.chess_map_from_alpha_to_index[column]
        i,j = row, column
        solutionMoves = []

        for k in range(1,8):
            try:
                temp = self.pieces[i + k][j]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i + k, j])
                    break
                elif temp * self[i][j] > 0:
                    break
                else: 
                    solutionMoves.append([i + k, j])            
            except:
                pass 

        for k in range(1,8):
            try:
                temp = self.pieces[i - k][j]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i - k, j])
                    break
                elif temp * self[i][j] > 0:
                    break
                else: 
                    solutionMoves.append([i - k, j])  
                
            except:
                pass

        for k in range(1,8):
            try:
                temp = self.pieces[i][j + k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i, j + k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else: 
                    solutionMoves.append([i, j + k])
            except:
                pass

        for k in range(1,8):
            try:
                temp = self.pieces[i][j - k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i, j - k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else:
                    solutionMoves.append([i, j - k])
                
            except:
                pass

        temp = [i for i in solutionMoves if i[0] >=0 and i[1] >=0]
        solutionMoves = ["".join([self.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)]) for i in temp]
        solutionMoves.sort()    

        return solutionMoves

    def getKnightMoves(self, pos, color):
        """ A function that returns the all possible moves
            of a knight stood on a given position
        """
        column, row = list(pos.strip().lower())
        row = int(row) - 1
        column = self.chess_map_from_alpha_to_index[column]
        i,j = row, column
        solutionMoves = []
        try:
            temp = self.pieces[i + 1][j - 2]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 1, j - 2])
        except:
            pass
        try:
            temp = self.pieces[i + 2][j - 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 2, j - 1])
        except:
            pass
        try:
            temp = self.pieces[i + 2][j + 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 2, j + 1])
        except:
            pass
        try:
            temp = self.pieces[i + 1][j + 2]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 1, j + 2])
        except:
            pass
        try:
            temp = self.pieces[i - 1][j + 2]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 1, j + 2])
        except:
            pass
        try:
            temp = self.pieces[i - 2][j + 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 2, j + 1])
        except:
            pass
        try:
            temp = self.pieces[i - 2][j - 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 2, j - 1])
        except:
            pass
        try:
            temp = self.pieces[i - 1][j - 2]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 1, j - 2])
        except:
            pass

        # Filter all negative values
        temp = [i for i in solutionMoves if i[0] >=0 and i[1] >=0]
        allPossibleMoves = ["".join([self.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)]) for i in temp]
        allPossibleMoves.sort()
        return allPossibleMoves

    def getBishopMoves(self, pos,color):
        column, row = list(pos.strip().lower())
        row = int(row) - 1
        column = self.chess_map_from_alpha_to_index[column]
        i,j = row, column
        solutionMoves = []

        # Compute the moves in Rank
        for k in range(1,8):
            try:
                temp = self.pieces[i + k][j + k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i + k, j + k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else:
                    solutionMoves.append([i + k, j + k])            
            except:
                pass 

        for k in range(1,8):
            try:
                temp = self.pieces[i + k][j - k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i + k, j - k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else: 
                    solutionMoves.append([i + k, j - k])  
                
            except:
                pass

        for k in range(1,8):
            try:
                temp = self.pieces[i - k][j + k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i - k, j + k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else: 
                    solutionMoves.append([i - k, j + k])
            except:
                pass

        for k in range(1,8):
            try:
                temp = self.pieces[i - k][j - k]
                if temp * self[i][j] < 0:
                    solutionMoves.append([i - k, j - k])
                    break
                elif temp * self[i][j] > 0:
                    break
                else:
                    solutionMoves.append([i - k, j - k])
                
            except:
                pass
        
        # print(solutionMoves)
        
        # Filter all negative values
        temp = [i for i in solutionMoves if i[0] >=0 and i[1] >=0]

        solutionMoves = ["".join([self.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)]) for i in temp]
        solutionMoves.sort()
        return solutionMoves

    def getQueenMoves(self, pos, color):
        solutionMoves = self.getBishopMoves(pos, color) + self.getRookMoves(pos, color)
        solutionMoves.sort()
        return solutionMoves

    def getKingMoves(self, pos, color):

        column, row = list(pos.strip().lower())
        row = int(row) - 1
        column = self.chess_map_from_alpha_to_index[column]
        i,j = row, column
        solutionMoves = []
        
        try:
            temp = self.pieces[i + 1][j]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 1, j])
        except:
            pass
        try:
            temp = self.pieces[i - 1][j]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 1, j])
        except:
            pass
        try:
            temp = self.pieces[i][j + 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i, j + 1])
        except:
            pass
        try:
            temp = self.pieces[i][j - 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i, j - 1])
        except:
            pass
        try:
            temp = self.pieces[i - 1][j - 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 1, j - 1])
        except:
            pass
        try:
            temp = self.pieces[i + 1][j + 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 1, j + 1])
        except:
            pass
        try:
            temp = self.pieces[i + 1][j - 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i + 1, j - 1])
        except:
            pass
        try:
            temp = self.pieces[i - 1][j + 1]
            if temp * self[i][j] <= 0:
                solutionMoves.append([i - 1, j + 1])
        except:
            pass

        # Filter all negative values
        temp = [i for i in solutionMoves if i[0] >=0 and i[1] >=0]

        solutionMoves = ["".join([self.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)]) for i in temp]
        solutionMoves.sort()
        return solutionMoves

    def getPawnMoves(self, pos, direction):

        column, row = list(pos.strip().lower())
        row = int(row) - 1
        column = self.chess_map_from_alpha_to_index[column]
        i,j = row, column
        solutionMoves = []
        
        if direction > 0:   
           
          try:
              temp = self.pieces[i + 1][j]
              if temp * self[i][j] == 0:
                  solutionMoves.append([i + 1, j])
          except:
              pass
          try:
              temp = self.pieces[i + 1][j + 1]
              if temp * self[i][j] < 0:
                  solutionMoves.append([i + 1, j + 1])
          except:
              pass
          try:
              temp = self.pieces[i + 1][j - 1]
              if temp * self[i][j] < 0:
                  solutionMoves.append([i + 1, j - 1])
          except:
              pass
          try:
              temp = self.pieces[i+2][j]
              if temp * self[i][j] == 0 and self.pieces[i+1][j] == 0 and i == 1:
                  solutionMoves.append([i+2, j])
          except:
              pass
        
    
        else:
            
          try:
              temp = self.pieces[i - 1][j]
              if temp * self[i][j] == 0:
                  solutionMoves.append([i - 1, j])
          except:
              pass
          try:
              temp = self.pieces[i - 1][j - 1]
              if temp * self[i][j] < 0:
                  solutionMoves.append([i - 1, j - 1])
          except:
              pass
          try:
              temp = self.pieces[i - 1][j + 1]
              if temp * self[i][j] < 0:
                  solutionMoves.append([i - 1, j + 1])
          except:
              pass
          try:
              temp = self.pieces[i-2][j]
              if temp * self[i][j] == 0 and self.pieces[i-1][j] == 0 and i == 6:
                  solutionMoves.append([i-2, j])
          except:
              pass
                
                
                
                        # Filter all negative values
        temp = [i for i in solutionMoves if i[0] >=0 and i[1] >=0]

        solutionMoves = ["".join([self.chess_map_from_index_to_alpha[i[1]], str(i[0] + 1)]) for i in temp]
        solutionMoves.sort()
        return solutionMoves

    def get_moves_for_square(self, square, direction):
        """Returns all the legal moves that use the given square as a base."""
        (x,y) = square
        move = self.chess_map_from_index_to_alpha[y] + str(x+1)

        # determine the color of the piece.
        piecetype, color = self.get_type(x,y)

        if piecetype == None:
            return []

        # search all possible directions.
        moves = []

        if abs(piecetype) == 1:
            moves = self.getPawnMoves(move, direction)
            # moves = self.getPawnMoves(move)
        elif abs(piecetype) ==2:
            moves = self.getKnightMoves(move, color)
        elif abs(piecetype) ==3:
            moves = self.getBishopMoves(move, color) 
        elif abs(piecetype) ==4:
            moves = self.getRookMoves(move, color)
        elif abs(piecetype) ==5:
            moves = self.getQueenMoves(move, color)
        elif abs(piecetype) ==6:
            moves = self.getKingMoves(move, color)

        ret = [(move, x) for x in moves]

        
        # return the generated move list
        return ret

    



    def execute_move(self, old_pos, move, en_passant=False):
        """Perform the given move on the board; flips pieces as necessary.
        """
        #self.direction_CURR = -self.direction_CURR
        #move = (col, row) in chess terms
        x, y = int(move[1]) - 1, self.chess_map_from_alpha_to_index[move[0]]

        x_old, y_old = int(old_pos[1]) - 1, self.chess_map_from_alpha_to_index[old_pos[0]]
        
        self[x][y] = self[x_old][y_old]
        self[x_old][y_old] = 0

        if en_passant:
            self[x_old][y_new] = 0

        #promotion
        if self[x][y] == 1:
            if x == 0 or x == 7:
                self[x][y] = 5
        
        if self[x][y] == -1:
            if x == 0 or x == 7:
                self[x][y] = -5


    def insufficientMaterial(self):
        temp = Board(self.pieces)

        wbishop = False
        bbishop = False

        firstW = True
        firstB = True

        whiteSquare = (9,9)
        blackSquare = (9,9)

        for i in range(0,8):
            for j in range (0,8):
                #white
                if temp[i][j] > 0:
                    if temp[i][j] == 6: #king
                        continue
                    elif temp[i][j] >= 4 or temp[i][j] == 1: #rook or queen or pawn
                        return False
                    elif temp[i][j] == 2:   #knight
                        
                        #A black piece has already been found
                        if firstB == False:
                            return False

                        #This is the first white knight or bishop found
                        if firstW == True:
                            firstW = False
                        else:
                            return False

                    elif temp[i][j] == 3:   #bishop
                        
                        #A black piece has already been found that is not a bishop
                        if firstB == False and bbishop == False:
                            return False

                        #This is the first white knight or bishop found
                        if firstW == True:
                            firstW = False
                            wbishop = True
                            whiteSquare = (i,j)
                        else:
                            return False

                #black
                if temp[i][j] < 0:
                    if temp[i][j] == -6: #king
                        continue
                    elif temp[i][j] <= 4 or temp[i][j] == -1: #rook or queen or pawn
                        return False
                    elif temp[i][j] == -2:   #knight
                        
                        #A white piece has already been found
                        if firstW == False:
                            return False

                        #This is the first black knight or bishop found
                        if firstB == True:
                            firstB = False
                        else:
                            return False

                    elif temp[i][j] == -3:   #bishop
                        
                        #A white piece has already been found that is not a bishop
                        if firstW == False and wbishop == False:
                            return False

                        #This is the first black knight or bishop found
                        if firstB == True:
                            firstB = False
                            bbishop = True
                            blackSquare = (i,j)
                        else:
                            return False
                        

        #At this point, we have insufficient material or two opposite color bishops
        
        #Only kings are on the board
        if (firstB and firstW) == True:
            return True

        #Only a black or a white piece exists. Insufficient material
        if (firstB or firstW) == True:
            return True

        
        #At this point, both sides have at least one bishop or one knight

        #One bishop for each player. Check the colors.
        if (bbishop and wbishop) == True:
            #function to check if they are on different colors

            xWhite, yWhite = whiteSquare
            xBlack, yBlack = blackSquare
            
            #same x
            if (xWhite % 2) == (xBlack % 2):
                #same y
                return ( (yWhite % 2) == (yBlack % 2) )
                    
                #different x
            else:
                #different y
                return ( (yWhite % 2) != (yBlack % 2) )
                    


    def is_in_check(self, old_pos, move, player, direction, en_passant = False):
        """player: player who is in check after the move
           direction: direction of OPPONENT player

        """

        x_old, y_old = int(old_pos[1]) - 1, self.chess_map_from_alpha_to_index[old_pos[0]]
        #The piece we are moving
        piece = self[x_old][y_old]

        #move = (col, row) in chess terms
        x, y = int(move[1]) - 1, self.chess_map_from_alpha_to_index[move[0]]
        captured_piece = self[x][y]
        
        flag = False
        #Do the move to check if it puts you in check
        self[x][y] = self[x_old][y_old]
        self[x_old][y_old] = 0

        if en_passant:
            temp_pawn = self[x_old][y_new]
            self[x_old][y_new] = 0

        # if self[x][y] == 6:
        #     self.wking = x,y
        # if self[x][y] == -6:
        #     self.bking = x,y


        piecetype, _ = self.get_type(x,y)

        color = player

        # if color > 0:
        #     x_king, y_king = self.wking
        # else:
        #     x_king, y_king = self.bking

        #king position
        for i in range(8):
            for j in range(8):
                if self[i][j] * color == 6:
                    x_king, y_king = i,j
                    break


        #x+
        for i in range(x_king+1, 8):
            if self[i][y_king] * color > 0:
                break
            elif self[i][y_king] * color < 0:
                enemy_piece, _ = self.get_type(i, y_king)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                    break
                elif enemy_piece == 6 and i - x_king == 1:
                    flag = True
                    break
                else:
                    break
        
        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old

            return flag


        #x-
        for i in range(x_king-1, -1, -1):
            if self[i][y_king] * color > 0:
                break
            elif self[i][y_king] * color < 0:
                enemy_piece, _ = self.get_type(i, y_king)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and x_king-i == 1:
                    flag = True
                break
        
        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            
            return flag  



        #y+
        for i in range(y_king+1, 8):
            if self[x_king][i] * color > 0:
                break
            elif self[x_king][i] * color < 0:
                enemy_piece, _ = self.get_type(x_king, i)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i-y_king == 1:
                    flag = True
                break
        
        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old

            return flag            

        
        #y-
        for i in range(y_king-1, -1, -1):
            
            if self[x_king][i] * color > 0:
                break
            elif self[x_king][i] * color < 0:
                enemy_piece, _ = self.get_type(x_king, i)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and y_king-i == 1:
                    flag = True
                break
        
        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            return flag


        #diagonals
        #upper right
        for i in range(1, 8):
            if x_king+i > 7 or y_king+i > 7:
                break

            if self[x_king+i][y_king+i] * color > 0:
                break
            elif self[x_king+i][y_king+i] * color < 0:
                enemy_piece, _ = self.get_type(x_king+i, y_king+i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == -1 and i == 1: #enemy pawn above you in the diagonal can capture you only if its direction is negative
                    flag = True
                break
        
        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            return flag
        
        #upper left
        for i in range(1, 8):
            if x_king+i > 7 or y_king-i < 0:
                break

            if self[x_king+i][y_king-i] * color > 0:
                break
            elif self[x_king+i][y_king-i] * color < 0:
                enemy_piece, _ = self.get_type(x_king+i, y_king-i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == -1 and i == 1: #enemy pawn above you in the diagonal can capture you only if its direction is negative
                    flag = True
                break

        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            return flag

        #lower right
        for i in range(1, 8):
            if x_king-i < 0 or y_king+i > 7:
                break

            if self[x_king-i][y_king+i] * color > 0:
                break
            elif self[x_king-i][y_king+i] * color < 0:
                enemy_piece, _ = self.get_type(x_king-i, y_king+i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == 1 and i == 1: #enemy pawn below you in the diagonal can capture you only if its direction is positive
                    flag = True
                break

        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            return flag


        #lower left
        for i in range(1, 8):
            if x_king-i < 0 or y_king-i < 0:
                break

            if self[x_king-i][y_king-i] * color > 0:
                break
            elif self[x_king-i][y_king-i] * color < 0:
                enemy_piece, _ = self.get_type(x_king-i, y_king-i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == 1 and i == 1: #enemy pawn below you in the diagonal can capture you only if its direction is positive
                    flag = True
                break

        if flag == True:
            #revert the board
            self[x][y] = captured_piece
            self[x_old][y_old] = piece

            if en_passant:
                self[x_old][y_new] = temp_pawn

            # if self[x_old][y_old] == 6:
            #     self.wking = x_old,y_old
            # if self[x_old][y_old] == -6:
            #     self.bking = x_old,y_old
            return flag

        #knight move checks

        if in_board(x_king+1, y_king+2):
            if self[x_king+1][y_king+2] * color < 0 and abs(self[x_king+1][y_king+2]) == 2:
                flag = True

        if in_board(x_king+1, y_king-2):
            if self[x_king+1][y_king-2] * color < 0 and abs(self[x_king+1][y_king-2]) == 2:
                flag = True

        if in_board(x_king+2, y_king+1):
            if self[x_king+2][y_king+1] * color < 0 and abs(self[x_king+2][y_king+1]) == 2:
                flag = True
        
        if in_board(x_king+2, y_king-1):
            if self[x_king+2][y_king-1] * color < 0 and abs(self[x_king+2][y_king-1]) == 2:
                flag = True


        if in_board(x_king-1, y_king+2):
            if self[x_king-1][y_king+2] * color < 0 and abs(self[x_king-1][y_king+2]) == 2:
                flag = True

        if in_board(x_king-1, y_king-2):
            if self[x_king-1][y_king-2] * color < 0 and abs(self[x_king-1][y_king-2]) == 2:
                flag = True

        if in_board(x_king-2, y_king+1):
            if self[x_king-2][y_king+1] * color < 0 and abs(self[x_king-2][y_king+1]) == 2:
                flag = True
        
        if in_board(x_king-2, y_king-1):
            if self[x_king-2][y_king-1] * color < 0 and abs(self[x_king-2][y_king-1]) == 2:
                flag = True
        
            #revert the board
        self[x][y] = captured_piece
        self[x_old][y_old] = piece

        if en_passant:
                self[x_old][y_new] = temp_pawn

        # if self[x_old][y_old] == 6:
        #     self.wking = x_old,y_old
        # if self[x_old][y_old] == -6:
        #     self.bking = x_old,y_old
        return flag


    


    def is_in_check_now(self, player, direction):
        flag = False

        color = player
        
        #king position
        for i in range(8):
            for j in range(8):
                if self[i][j] * color == 6:
                    x_king, y_king = i,j
                    break
                    
        #x+
        for i in range(x_king+1, 8):
            if self[i][y_king] * color > 0:
                break
            elif self[i][y_king] * color < 0:
                enemy_piece, _ = self.get_type(i, y_king)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                    break
                elif enemy_piece == 6 and i - x_king == 1:
                    flag = True
                    break
                else:
                    break
        
        if flag == True:
            return flag

        #x-
        for i in range(x_king-1, -1, -1):
            if self[i][y_king] * color > 0:
                break
            elif self[i][y_king] * color < 0:
                enemy_piece, _ = self.get_type(i, y_king)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and x_king-i == 1:
                    flag = True
                break

        if flag == True:
            return flag  



        #y+
        for i in range(y_king+1, 8):
            if self[x_king][i] * color > 0:
                break
            elif self[x_king][i] * color < 0:
                enemy_piece, _ = self.get_type(x_king, i)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i-y_king == 1:
                    flag = True
                break


        if flag == True:
            return flag        

        
        #y-
        for i in range(y_king-1, -1, -1):
            if self[x_king][i] * color > 0:
                break
            elif self[x_king][i] * color < 0:
                enemy_piece, _ = self.get_type(x_king, i)
                if enemy_piece == 4 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and y_king-i == 1:
                    flag = True
                break
        

        if flag == True:
            return flag


        #diagonals
        #upper right
        for i in range(1, 8):
            if x_king+i > 7 or y_king+i > 7:
                break

            if self[x_king+i][y_king+i] * color > 0:
                break
            elif self[x_king+i][y_king+i] * color < 0:
                enemy_piece, _ = self.get_type(x_king+i, y_king+i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == -1 and i == 1: #enemy pawn above you in the diagonal can capture you only if its direction is negative
                    flag = True
                break
        

        if flag == True:
            return flag
        
        #upper left
        for i in range(1, 8):
            if x_king+i > 7 or y_king-i < 0:
                break

            if self[x_king+i][y_king-i] * color > 0:
                break
            elif self[x_king+i][y_king-i] * color < 0:
                enemy_piece, _ = self.get_type(x_king+i, y_king-i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == -1 and i == 1: #enemy pawn above you in the diagonal can capture you only if its direction is negative
                    flag = True
                break


        if flag == True:
            return flag

        #lower right
        for i in range(1, 8):
            if x_king-i < 0 or y_king+i > 7:
                break

            if self[x_king-i][y_king+i] * color > 0:
                break
            elif self[x_king-i][y_king+i] * color < 0:
                enemy_piece, _ = self.get_type(x_king-i, y_king+i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == 1 and i == 1: #enemy pawn below you in the diagonal can capture you only if its direction is positive
                    flag = True
                break


        if flag == True:
            return flag


        #lower left
        for i in range(1, 8):
            if x_king-i < 0 or y_king-i < 0:
                break

            if self[x_king-i][y_king-i] * color > 0:
                break
            elif self[x_king-i][y_king-i] * color < 0:
                enemy_piece, _ = self.get_type(x_king-i, y_king-i)
                if enemy_piece == 3 or enemy_piece == 5:
                    flag = True
                elif enemy_piece == 6 and i == 1:
                    flag = True
                elif enemy_piece == 1 and direction == 1 and i == 1: #enemy pawn below you in the diagonal can capture you only if its direction is positive
                    flag = True
                break


        if flag == True:
            return flag

        #knight move checks

        if in_board(x_king+1, y_king+2):
            if self[x_king+1][y_king+2] * color < 0 and abs(self[x_king+1][y_king+2])*color == 2*(-color):
                flag = True

        if in_board(x_king+1, y_king-2):
            if self[x_king+1][y_king-2] * color < 0 and abs(self[x_king+1][y_king-2])*color == 2*(-color):
                flag = True

        if in_board(x_king+2, y_king+1):
            if self[x_king+2][y_king+1] * color < 0 and abs(self[x_king+2][y_king+1])*color == 2*(-color):
                flag = True
        
        if in_board(x_king+2, y_king-1):
            if self[x_king+2][y_king-1] * color < 0 and abs(self[x_king+2][y_king-1])*color == 2*(-color):
                flag = True


        if in_board(x_king-1, y_king+2):
            if self[x_king-1][y_king+2] * color < 0 and abs(self[x_king-1][y_king+2])*color == 2*(-color):
                flag = True

        if in_board(x_king-1, y_king-2):
            if self[x_king-1][y_king-2] * color < 0 and abs(self[x_king-1][y_king-2])*color == 2*(-color):
                flag = True

        if in_board(x_king-2, y_king+1):
            if self[x_king-2][y_king+1] * color < 0 and abs(self[x_king-2][y_king+1])*color == 2*(-color):
                flag = True
        
        if in_board(x_king-2, y_king-1):
            if self[x_king-2][y_king-1] * color < 0 and abs(self[x_king-2][y_king-1])*color == 2*(-color):
                flag = True


        return flag
        


    # material_count()

    #castling()

    #en_passant()

#fool's mate

# print(b.is_in_check('e2','e4',1))

# b = Board(8)

# b2 = Board(b)


# b.printBoard()
# b.execute_move('e2','e4')

# b.execute_move('a7','a6')
# b.execute_move('d1','f3')
# b.execute_move('a6','a5')
# b.execute_move('f1','c4')
# b.execute_move('a5','a4')

# print(b.is_in_check('f3','f7',-1))

# b.execute_move('f3','f7')

# b.printBoard()
# print(b.is_in_check_now(-1))

"""##NETWORK

"""

class NeuralNet():
    """
    This class specifies the base NeuralNet class. To define your own neural
    network, subclass this class and implement the functions below. The neural
    network does not consider the current player, and instead only deals with
    the canonical form of the board.
    """

    def __init__(self, game):
        pass

    def train(self, examples):
        """
        This function trains the neural network with examples obtained from
        self-play.
        Input:
            examples: a list of training examples, where each example is of form
                      (board, pi, v). pi is the MCTS informed policy vector for
                      the given board, and v is its value. The examples has
                      board in its canonical form.
        """
        pass

    def predict(self, board):
        """
        Input:
            board: current board in its canonical form.
        Returns:
            pi: a policy vector for the current board- a numpy array of length
                game.getActionSize
            v: a float in [-1,1] that gives the value of the current board
        """
        pass

    def save_checkpoint(self, folder, filename):
        """
        Saves the current neural network (with its parameters) in
        folder/filename
        """
        pass

    def load_checkpoint(self, folder, filename):
        """
        Loads parameters of the neural network from folder/filename
        """
        pass

import sys

import argparse
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms
from torch.autograd import Variable

class ChessNNet(nn.Module):
    def __init__(self, game, args):
        # game params
        self.board_x, self.board_y = game.getBoardSize()
        self.action_size = game.getActionSize()
        self.args = args

        super(ChessNNet, self).__init__()
        self.conv1 = nn.Conv3d(1, args.num_channels, 3, stride=1, padding=1)
        self.conv2 = nn.Conv3d(args.num_channels, args.num_channels, 3, stride=1, padding=1)
        self.conv3 = nn.Conv3d(args.num_channels, args.num_channels, 3, stride=1)
        self.conv4 = nn.Conv3d(args.num_channels, args.num_channels, 3, stride=1)

        self.bn1 = nn.BatchNorm3d(args.num_channels)
        self.bn2 = nn.BatchNorm3d(args.num_channels)
        self.bn3 = nn.BatchNorm3d(args.num_channels)
        self.bn4 = nn.BatchNorm3d(args.num_channels)

        self.fc1 = nn.Linear(args.num_channels*(self.board_x-4)*(self.board_y-4) * (16-4), 1024)
        self.fc_bn1 = nn.BatchNorm1d(1024)

        self.fc2 = nn.Linear(1024, 512)
        self.fc_bn2 = nn.BatchNorm1d(512)

        self.fc3 = nn.Linear(512, self.action_size)

        self.fc4 = nn.Linear(512, 1)

    def forward(self, s):
        #                                                           s: batch_size x board_x x board_y x ?
        s = s.view(-1, 1, self.board_x, self.board_y, 16)                # batch_size x 1 x board_x x board_y x ?
        print(s.size())
        s = F.relu(self.bn1(self.conv1(s)))                          # batch_size x num_channels x board_x x board_y x ?
        print(s.size())
        s = F.relu(self.bn2(self.conv2(s)))                          # batch_size x num_channels x board_x x board_y x ?
        print(s.size())
        s = F.relu(self.bn3(self.conv3(s)))                          # batch_size x num_channels x (board_x-2) x (board_y-2) x ?
        print(s.size())
        s = F.relu(self.bn4(self.conv4(s)))                          # batch_size x num_channels x (board_x-4) x (board_y-4) x ?
        print(s.size())
        s = s.view(-1, self.args.num_channels*(self.board_x-4)*(self.board_y-4) * (16-4))

        s = F.dropout(F.relu(self.fc_bn1(self.fc1(s))), p=self.args.dropout, training=self.training)  # batch_size x 1024
        s = F.dropout(F.relu(self.fc_bn2(self.fc2(s))), p=self.args.dropout, training=self.training)  # batch_size x 512

        pi = self.fc3(s)                                                                         # batch_size x action_size
        v = self.fc4(s)                                                                          # batch_size x 1


        return F.log_softmax(pi, dim=1), torch.tanh(v)

class AverageMeter(object):
    def __init__(self):
        self.reset()

    def reset(self):
        self.val = 0
        self.avg = 0
        self.sum = 0
        self.count = 0

    def __repr__(self):
        return f'{self.avg:.2e}'

    def update(self, val, n=1):
        self.val = val
        self.sum += val * n
        self.count += n
        self.avg = self.sum / self.count

import os
import sys
import time

import numpy as np
from tqdm import tqdm

# from NeuralNet import NeuralNet

import torch
import torch.optim as optim
# from .ChessNNet import ChessNNet as onnet

class dotdict(dict):
    def __getattr__(self, name):
        return self[name]

args = dotdict({
    'lr': 0.0001,
    'dropout': 0.5,
    'epochs': 10,
    'batch_size': 128,
    'cuda': torch.cuda.is_available(),
    'num_channels': 512,
})


class NNetWrapper(NeuralNet):
    def __init__(self, game):
        self.nnet = ChessNNet(game, args)
        self.board_x, self.board_y = game.getBoardSize()
        self.action_size = game.getActionSize()

        if args.cuda:
            self.nnet.cuda()

    def train(self, examples):
        """
        examples: list of examples, each example is of form (board, pi, v)
        """
        optimizer = optim.Adam(self.nnet.parameters())

        for epoch in range(args.epochs):
            print('EPOCH ::: ' + str(epoch + 1))
            self.nnet.train()
            pi_losses = AverageMeter()
            v_losses = AverageMeter()

            batch_count = int(len(examples) / args.batch_size)

            t = tqdm(range(batch_count), desc='Training Net')
            for _ in t:
                sample_ids = np.random.randint(len(examples), size=args.batch_size)
                boards, pis, vs = list(zip(*[examples[i] for i in sample_ids]))
                boards = torch.FloatTensor(np.array(boards).astype(np.float64))
                target_pis = torch.FloatTensor(np.array(pis))
                target_vs = torch.FloatTensor(np.array(vs).astype(np.float64))

                # predict
                if args.cuda:
                    boards, target_pis, target_vs = boards.contiguous().cuda(), target_pis.contiguous().cuda(), target_vs.contiguous().cuda()

                # compute output
                out_pi, out_v = self.nnet(boards)
                l_pi = self.loss_pi(target_pis, out_pi)
                l_v = self.loss_v(target_vs, out_v)
                total_loss = l_pi + l_v

                # record loss
                pi_losses.update(l_pi.item(), boards.size(0))
                v_losses.update(l_v.item(), boards.size(0))
                t.set_postfix(Loss_pi=pi_losses, Loss_v=v_losses)

                # compute gradient and do SGD step
                optimizer.zero_grad()
                total_loss.backward()
                optimizer.step()
            # print( 'pi_Loss: {:.6f}'.format(pi_losses.avg))
            # print( 'v_Loss: {:.6f}'.format(v_losses.avg))
            # print( 'total_loss: {:.6f}'.format(total_loss.avg))


    def predict(self, board):
        """
        board: np array with board
        """
        # timing
        start = time.time()

        # preparing input
        board = torch.FloatTensor(board.astype(np.float64))
        if args.cuda: board = board.contiguous().cuda()
        board = board.view(1, self.board_x, self.board_y, 16)
        self.nnet.eval()
        with torch.no_grad():
            pi, v = self.nnet(board)

        # print('PREDICTION TIME TAKEN : {0:03f}'.format(time.time()-start))
        return torch.exp(pi).data.cpu().numpy()[0], v.data.cpu().numpy()[0]

    def loss_pi(self, targets, outputs):
        return -torch.sum(targets * outputs) / targets.size()[0]

    def loss_v(self, targets, outputs):
        return torch.sum((targets - outputs.view(-1)) ** 2) / targets.size()[0]

    def save_checkpoint(self, folder='checkpoint', filename='checkpoint.pth.tar'):
        filepath = os.path.join(folder, filename)
        if not os.path.exists(folder):
            print("Checkpoint Directory does not exist! Making directory {}".format(folder))
            os.mkdir(folder)
        else:
            print("Checkpoint Directory exists! ")
        torch.save({
            'state_dict': self.nnet.state_dict(),
        }, filepath)

    def load_checkpoint(self, folder='checkpoint', filename='checkpoint.pth.tar'):
        # https://github.com/pytorch/examples/blob/master/imagenet/main.py#L98
        filepath = os.path.join(folder, filename)
        if not os.path.exists(filepath):
            raise("No model in path {}".format(filepath))
        map_location = None if args.cuda else 'cpu'
        checkpoint = torch.load(filepath, map_location=map_location)
        self.nnet.load_state_dict(checkpoint['state_dict'])

"""##MCTS

"""

import logging
import math
import random

import numpy as np

import sys
sys.setrecursionlimit(10000)

EPS = 1e-8

log = logging.getLogger(__name__)


class MCTS():
    """
    This class handles the MCTS tree.
    """

    def __init__(self, game, nnet, args):
        self.game = game
        self.nnet = nnet
        self.args = args
        self.Qsa = {}  # stores Q values for s,a (as defined in the paper)
        self.Nsa = {}  # stores #times edge s,a was visited
        self.Ns = {}  # stores #times board s was visited
        self.Ps = {}  # stores initial policy (returned by neural net)

        self.Es = {}  # stores game.getGameEnded ended for board s
        self.Vs = {}  # stores game.getValidMoves for board s


        self.draw=0
        self.seed = np.arange(1,4097)

    def getActionProb(self, canonicalBoard, temp=1, train=True):
        """
        This function performs numMCTSSims simulations of MCTS starting from
        canonicalBoard.
        Returns:
            probs: a policy vector where the probability of the ith action is
                   proportional to Nsa[(s,a)]**(1./temp)
        """

                
        player=1
        for i in range(self.args.numMCTSSims):
            direction = self.game.direction
            posCounter = dict(self.game.posCounter)
            progress = self.game.progress
            en_passant = self.game.en_passant
            moves = self.game.moves

            self.draw = 0
            self.search(canonicalBoard,player,train)

            self.game.en_passant = en_passant
            self.game.posCounter = dict(posCounter)
            self.game.direction = direction
            self.game.progress = progress
            self.game.moves = moves
        
        # if train == False:
        #     self.game.direction = -self.game.direction


        s = self.game.stringRepresentation(canonicalBoard)
        
        counts = [self.Nsa[(s, a)]  if (s, a) in self.Nsa else 0 for a in range(self.game.getActionSize())]
        
        

        #after some threshold, we choose the next move by chance
        #the most visited nodes have a greater chance
        if temp == 0:

            # #mask the invalid moves from counts
            # valids = self.game.getValidMoves(canonicalBoard, 1)
            # counts = counts * valids

            bestAs = np.array(np.argwhere(counts == np.max(counts))).flatten()
            bestA = np.random.choice(bestAs)
            probs = [0] * len(counts)
            probs[bestA] = 1
            # print(bestAs)
            # print(bestA)
            # print(f'{np.max(counts)} - {len(bestAs)}')
            if np.max(counts) == 0:
                print(s)
                assert(False)
                
            return probs


        counts = [x ** (1. / temp) for x in counts]
        counts_sum = float(sum(counts))

        #if counts_sum is 0, give the same probability to every action
        if counts_sum != 0:
            probs = [x / counts_sum for x in counts]
        else:
            probs = [1 / len(counts) for x in counts]

            print("Zerooooo")

        return probs

    def search(self, canonicalBoard,player,train):
        """
        This function performs one iteration of MCTS. It is recursively called
        till a leaf node is found. The action chosen at each node is one that
        has the maximum upper confidence bound as in the paper.
        Once a leaf node is found, the neural network is called to return an
        initial policy P and a value v for the state. This value is propagated
        up the search path. In case the leaf node is a terminal state, the
        outcome is propagated up the search path. The values of Ns, Nsa, Qsa are
        updated.
        NOTE: the return values are the negative of the value of the current
        state. This is done since v is in [-1,1] and if v is the value of a
        state for the current player, then its value is -v for the other player.
        Returns:
            v: the negative of the value of the current canonicalBoard
        """
        
        # if self.draw > 200:
        #     print("lathos333333")
        #     return random.uniform(-0.5, 0.5)

        # self.draw+=1
    
        s = self.game.stringRepresentation(canonicalBoard)

        if s not in self.Es:
            self.Es[s] = self.game.getGameEnded(canonicalBoard, 1)
        if self.Es[s] != 0:
            # terminal node
            return -self.Es[s]

        if s not in self.Ps:
            # leaf node
            input = np.zeros((8,8,16))

            for i in range(8):
                for j in range(8):
                    if canonicalBoard[i][j] < 0:
                        input[i][j][canonicalBoard[i][j] + 6] = 1
                    elif canonicalBoard[i][j] > 0:
                        input[i][j][canonicalBoard[i][j] + 5] = 1
                    
                    #color
                    input[i][j][12] = self.game.direction #?

                    #moves
                    input[i][j][13] = self.game.moves

                    #repetitions
                    if s in self.game.posCounter:
                        self.game.posCounter[s] += 1  #?
                    else:
                        self.game.posCounter[s] = 1

                    input[i][j][14] = self.game.posCounter[s]

                    #progress
                    input[i][j][15] = self.game.progress

            self.Ps[s], v = self.nnet.predict(input)

            #Add noise during training to make it explore more moves
            if train:
                #add dirichlet noise to probability vector
                noise = np.random.dirichlet(self.seed)*0.3

                #adding noise to probs
                temp = self.Ps[s] + noise

                #renormalize 
                prob_sum = float(sum(temp))
                self.Ps[s] = np.array([x / prob_sum for x in temp])


            valids = self.game.getValidMoves(canonicalBoard, 1)
            # print("----------------------------")
            # print(s)
            # for i in range(len(valids)):
            #     if valids[i] != 0:
            #         old, new = np.unravel_index(i, (64,64))
            #         x_old, y_old = np.unravel_index(old, (8,8))
            #         x_new, y_new = np.unravel_index(new, (8,8))
            #         print(f'{x_old}{y_old} -> {x_new}{y_new}')
            # print("----------------------------------------\n\n")

            self.Ps[s] = self.Ps[s] * valids  # masking invalid moves
            sum_Ps_s = np.sum(self.Ps[s])
            if sum_Ps_s > 0:
                self.Ps[s] /= sum_Ps_s  # renormalize
            else:
                # if all valid moves were masked make all valid moves equally probable

                # NB! All valid moves may be masked if either your NNet architecture is insufficient or you've get overfitting or something else.
                # If you have got dozens or hundreds of these messages you should pay attention to your NNet and/or training process.   
                log.error("All valid moves were masked, doing a workaround.")
                print("All valid moves were masked, doing a workaround.")
                self.Ps[s] = self.Ps[s] + valids
                self.Ps[s] /= np.sum(self.Ps[s])

            self.Vs[s] = valids
            self.Ns[s] = 0

            return -v
        

        valids = self.Vs[s]
        cur_best = -float('inf')
        best_act = -1

        # pick the action with the highest upper confidence bound
        for a in range(self.game.getActionSize()):
            if valids[a]:
                if (s, a) in self.Qsa:
                    u = self.Qsa[(s, a)] + self.args.cpuct * self.Ps[s][a] * math.sqrt(self.Ns[s]) / (
                            1 + self.Nsa[(s, a)])
                else:
                    u = self.args.cpuct * self.Ps[s][a] * math.sqrt(self.Ns[s] + EPS)  # Q = 0 ?

                if u > cur_best:
                    cur_best = u
                    best_act = a
        
        a = best_act

        # old, new = np.unravel_index(a, (64,64))
        # x_old, y_old = np.unravel_index(old, (8,8))
        # x_new, y_new = np.unravel_index(new, (8,8))

        # print(x_old,y_old)
        # print(x_new, y_new)

        next_s, next_player = self.game.getNextState(canonicalBoard, 1, a)
        next_s = self.game.getCanonicalForm(next_s, next_player)


        #-----------non terminal checks for draw------------------
        
        #3-fold repetition draw
        stringB = self.game.stringRepresentation(next_s)
        if stringB in self.game.posCounter:
            if self.game.posCounter[stringB] >= 3:

                v = 1e-4
                
                if (s, a) in self.Nsa:
                    self.Qsa[(s, a)] = (self.Nsa[(s, a)] * self.Qsa[(s, a)] + v) / (self.Nsa[(s, a)] + 1)
                    self.Nsa[(s, a)] += 1

                else:
                    self.Qsa[(s, a)] = v
                    self.Nsa[(s, a)] = 1
                self.Ns[s] += 1

                return -v #return negative draw


        #progress (pawn moves)
        if self.game.progress >= 50:
            v = 1e-4
                
            if (s, a) in self.Nsa:
                self.Qsa[(s, a)] = (self.Nsa[(s, a)] * self.Qsa[(s, a)] + v) / (self.Nsa[(s, a)] + 1)
                self.Nsa[(s, a)] += 1

            else:
                self.Qsa[(s, a)] = v
                self.Nsa[(s, a)] = 1
            self.Ns[s] += 1

            return -v #return negative draw


        #-----------non terminal checks for draw------------------
        


        
        # self.draw+=1
        
        # if self.draw > 100:
        #     print("-------------------------------")
        #     old, new = np.unravel_index(a, (64,64))
        #     x_old, y_old = np.unravel_index(old, (8,8))
        #     x_new, y_new = np.unravel_index(new, (8,8))

        #     print(x_old,y_old)
        #     print(x_new, y_new)
        #     print(canonicalBoard)
        #     print("-------------------------------")
            
        v = self.search(next_s,next_player,train)

        # self.draw-=1

        if (s, a) in self.Nsa:
            self.Qsa[(s, a)] = (self.Nsa[(s, a)] * self.Qsa[(s, a)] + v) / (self.Nsa[(s, a)] + 1)
            self.Nsa[(s, a)] += 1

        else:
            self.Qsa[(s, a)] = v
            self.Nsa[(s, a)] = 1
        self.Ns[s] += 1


        return -v

"""##ARENA"""

import logging

from tqdm import tqdm

log = logging.getLogger(__name__)


class Arena():
    """
    An Arena class where any 2 agents can be pit against each other.
    """

    def __init__(self, player1, player2, game, display=None):
        """
        Input:
            player 1,2: two functions that takes board as input, return action
            game: Game object
            display: a function that takes board as input and prints it (e.g.
                     display in othello/OthelloGame). Is necessary for verbose
                     mode.
        see othello/OthelloPlayers.py for an example. See pit.py for pitting
        human players/other baselines with each other.
        """
        self.player1 = player1
        self.player2 = player2
        self.game = game
        # self.display = display

    def display(self, board):
        for x in range(8):
            top = ' '
            for y in range(8):
                if str(board[x][y])[0] == '-':
                    top = top[:-1]
                top+=str(board[x][y])
                top+="        "
            print(top)
        print("\n\n")


    def playGame(self, verbose=False):
        """
        Executes one episode of a game.
        Returns:
            either
                winner: player who won the game (1 if player1, -1 if player2)
            or
                draw result returned from the game that is neither 1, -1, nor 0.
        """
        players = [self.player2, None, self.player1]
        curPlayer = 1
        self.game.revertBoard()
        board = self.game.getInitBoard()
        it = 0
        while self.game.getGameEnded(board, curPlayer) == 0:
            it += 1
            if verbose:
                assert self.display
                
                if players[curPlayer + 1] == self.player1:
                    print("Turn ", str(it), "Player 1")
                else:
                    print("Turn ", str(it), "Player 2")
                    
                self.display(board)
            
            action = players[curPlayer + 1](self.game.getCanonicalForm(board, curPlayer))

            valids = self.game.getValidMoves(self.game.getCanonicalForm(board, curPlayer), 1)
            
            
            # print("############################################")
            # for i in range(len(valids)):
            #   if valids[i] > 0:
            #     print(i)    
            # print("############################################")          
            
            
            
            # print(board)
            # old, new = np.unravel_index(action, (64,64))

            # x_old, y_old = np.unravel_index(old, (8,8))
            # x_new, y_new = np.unravel_index(new, (8,8))
            # print(x_old,y_old)
            # print(x_new,y_new)


            if valids[action] == 0:
                print(board)
                log.error(f'Action {action} is not valid!')
                log.debug(f'valids = {valids}')
                old, new = np.unravel_index(action, (64,64))

                x_old, y_old = np.unravel_index(old, (8,8))
                x_new, y_new = np.unravel_index(new, (8,8))
                print("MOVE:")
                print(x_old,y_old)
                print(x_new,y_new)

                print("Move List:")
                for i in range(len(valids)):
                    if valids[i] > 0:
                        old, new = np.unravel_index(i, (64,64))
                        x_old, y_old = np.unravel_index(old, (8,8))
                        x_new, y_new = np.unravel_index(new, (8,8))

                        print(x_old,y_old)
                        print(x_new,y_new)
                        print("----------")
                        
                
                assert valids[action] > 0
            board, curPlayer = self.game.getNextState(board, curPlayer, action)
        if verbose:
            assert self.display
            print("Game over: Turn ", str(it), "Result ", str(self.game.getGameEnded(board, 1)))
            self.display(board)
        print(it)
        # return curPlayer * self.game.getGameEnded(board, curPlayer)
        return self.game.getGameEnded(board, curPlayer)
        
    def playGames(self, num, verbose=False):
        """
        Plays num games in which player1 starts num/2 games and player2 starts
        num/2 games.
        Returns:
            oneWon: games won by player1
            twoWon: games won by player2
            draws:  games won by nobody
        """

        num = int(num / 2)
        oneWon = 0
        twoWon = 0
        draws = 0
        for _ in tqdm(range(num), desc="Arena.playGames (1)"):
            gameResult = self.playGame(verbose=verbose)
            if gameResult == 1:
                print("NIKHSA")
                oneWon += 1
            elif gameResult == -1:
                print("EXASA")
                twoWon += 1
            else:
                print("ISOPALIA")
                draws += 1

        self.player1, self.player2 = self.player2, self.player1

        for _ in tqdm(range(num), desc="Arena.playGames (2)"):
            gameResult = self.playGame(verbose=verbose)
            if gameResult == -1:
                print("NIKHSA")
                oneWon += 1
            elif gameResult == 1:
                print("EXASA")
                twoWon += 1
            else:
                print("ISOPALIA")
                draws += 1
        
        print("One won: ")
        print(oneWon)
        print("Two won: ")
        print(twoWon)
        print("Draws: ")
        print(draws)

        return oneWon, twoWon, draws

"""##COACH"""

import logging
import os
import sys
from collections import deque
from pickle import Pickler, Unpickler
from random import shuffle

import numpy as np
from tqdm import tqdm

# from Arena import Arena
# from MCTS import MCTS

log = logging.getLogger(__name__)


class Coach():
    """
    This class executes the self-play + learning. It uses the functions defined
    in Game and NeuralNet. args are specified in main.py.
    """

    def __init__(self, game, nnet, args):
        self.game = game
        self.nnet = nnet
        self.pnet = self.nnet.__class__(self.game)  # the competitor network
        self.args = args
        self.mcts = MCTS(self.game, self.nnet, self.args)
        self.trainExamplesHistory = []  # history of examples from args.numItersForTrainExamplesHistory latest iterations
        self.skipFirstSelfPlay = False  # can be overriden in loadTrainExamples()

        self.counter=0

    def executeEpisode(self):
        """
        This function executes one episode of self-play, starting with player 1.
        As the game is played, each turn is added as a training example to
        trainExamples. The game is played till the game ends. After the game
        ends, the outcome of the game is used to assign values to each example
        in trainExamples.
        It uses a temp=1 if episodeStep < tempThreshold, and thereafter
        uses temp=0.
        Returns:
            trainExamples: a list of examples of the form (canonicalBoard, currPlayer, pi,v)
                           pi is the MCTS informed policy vector, v is +1 if
                           the player eventually won the game, else -1.
        """
        trainExamples = []
        board = self.game.getInitBoard()
        self.curPlayer = 1
        episodeStep = 0

        canonicalBoard = self.game.getCanonicalForm(board, self.curPlayer)

        while True:
            episodeStep += 1

            canonicalBoard = self.game.getCanonicalForm(board, self.curPlayer)
            temp = int(episodeStep < self.args.tempThreshold)

            pi = self.mcts.getActionProb(canonicalBoard, temp=temp)
            
            
            trainExamples.append([canonicalBoard, self.curPlayer, list(pi), None])


            action = np.random.choice(len(pi), p=pi)
            board, self.curPlayer = self.game.getNextState(board, self.curPlayer, action)

            canonicalBoard = self.game.getCanonicalForm(board, self.curPlayer)



            r = self.game.getGameEnded(board, self.curPlayer)

            if r != 0:
                #curPlayer has lost!
                print(f'Won: {r}, Player: {self.curPlayer}')
                ret = []
                for x in trainExamples:
                    if x[1] == self.curPlayer: #if x[1] lost
                        result = -1
                    else:
                        result = 1

                    if r < 0.5 and r > -0.5: #if there was a draw, append -1
                        result = -1


                    input = np.zeros((8,8,16))

                    #1-6 white

                    for i in range(8):
                        for j in range(8):
                            if x[0][i][j] < 0:
                                input[i][j][x[0][i][j] + 6] = 1
                            elif x[0][i][j] > 0:
                                input[i][j][x[0][i][j] + 5] = 1
                            
                            #color
                            input[i][j][12] = x[1]

                            #moves
                            input[i][j][13] = self.game.moves

                            #repetitions
                            stringB = self.game.stringRepresentation(self.game.getCanonicalForm(x[0],x[1]))

                            if stringB in self.game.posCounter:
                                # print("ena", str(x[1]))
                                input[i][j][14] = self.game.posCounter[stringB]
                            else:
                                stringB2 = self.game.stringRepresentation(self.game.getCanonicalForm(x[0],-x[1]))
                                if stringB2 in self.game.posCounter:
                                    # print("dyo", str(x[1]))
                                    input[i][j][14] = self.game.posCounter[stringB2]
                                else:
                                    self.game.posCounter[stringB] = 1
                                    print("tria")
                                    input[i][j][14] = self.game.posCounter[stringB]


                            #progress
                            input[i][j][15] = self.game.progress
                    


                    
                    # ret.append((x[0],x[2],result))
                    ret.append((input,x[2],result))  

                return ret
              

                # for x in trainExamples:
                #     print(f'Moves: {episodeStep}. Winner: {r}, to kanw {r2}, epistrefw {r2 * ((-1) ** (x[1] != self.curPlayer))}')

                # return [(x[0], x[2], r2 * ((-1) ** (x[1] != self.curPlayer))) for x in trainExamples]

    def learn(self):
        """
        Performs numIters iterations with numEps episodes of self-play in each
        iteration. After every iteration, it retrains neural network with
        examples in trainExamples (which has a maximum length of maxlenofQueue).
        It then pits the new neural network against the old one and accepts it
        only if it wins >= updateThreshold fraction of games.
        """

        for i in range(1, self.args.numIters + 1):
            # bookkeeping
            log.info(f'Starting Iter #{i} ...')
            # examples of the iteration
            if not self.skipFirstSelfPlay or i > 1:
                iterationTrainExamples = deque([], maxlen=self.args.maxlenOfQueue)

                for _ in tqdm(range(self.args.numEps), desc="Self Play"):
                    self.mcts = MCTS(self.game, self.nnet, self.args)  # reset search tree
                    iterationTrainExamples += self.executeEpisode()
                    self.game.revertBoard()
                    self.counter+=1

                # save the iteration examples to the history 
                self.trainExamplesHistory.append(iterationTrainExamples)

            if len(self.trainExamplesHistory) > self.args.numItersForTrainExamplesHistory:
                log.warning(
                    f"Removing the oldest entry in trainExamples. len(trainExamplesHistory) = {len(self.trainExamplesHistory)}")
                self.trainExamplesHistory.pop(0)

            # backup history to a file
            # NB! the examples were collected using the model from the previous iteration, so (i-1)  
            # self.saveTrainExamples(i - 1)

            
            # shuffle examples before training
            trainExamples = []
            for e in self.trainExamplesHistory:
                trainExamples.extend(e)
            shuffle(trainExamples)

            # training new network, keeping a copy of the old one
            self.nnet.save_checkpoint(folder=self.args.checkpoint, filename='temp.pth.tar')
            self.pnet.load_checkpoint(folder=self.args.checkpoint, filename='temp.pth.tar')
            pmcts = MCTS(self.game, self.pnet, self.args)


            self.nnet.train(trainExamples)
            nmcts = MCTS(self.game, self.nnet, self.args)


            log.info('PITTING AGAINST PREVIOUS VERSION')
            arena = Arena(lambda x: np.argmax(pmcts.getActionProb(x, temp=0, train=False)),
                          lambda x: np.argmax(nmcts.getActionProb(x, temp=0, train=False)), self.game, display)
            # nwins, pwins, draws = arena.playGames(self.args.arenaCompare, verbose=True)
            nwins, pwins, draws = arena.playGames(self.args.arenaCompare)
            
            print('NEW/PREV WINS : %d / %d ; DRAWS : %d' % (nwins, pwins, draws))
            if pwins + nwins == 0 or float(nwins) / (pwins + nwins) < self.args.updateThreshold:
                print('REJECTING NEW MODEL')
                self.nnet.load_checkpoint(folder=self.args.checkpoint, filename='temp.pth.tar')
            else:
                print('ACCEPTING NEW MODEL')
                self.nnet.save_checkpoint(folder=self.args.checkpoint, filename=self.getCheckpointFile(i))
                self.nnet.save_checkpoint(folder=self.args.checkpoint, filename='best.pth.tar')

    def getCheckpointFile(self, iteration):
        return 'checkpoint_' + str(iteration) + '.pth.tar'

    def saveTrainExamples(self, iteration):
        folder = self.args.checkpoint
        if not os.path.exists(folder):
            os.makedirs(folder)
        filename = os.path.join(folder, self.getCheckpointFile(iteration) + ".examples")
        with open(filename, "wb+") as f:
            Pickler(f).dump(self.trainExamplesHistory)
        f.closed

    def loadTrainExamples(self):
        modelFile = os.path.join(self.args.load_folder_file[0], self.args.load_folder_file[1])
        examplesFile = modelFile + ".examples"
        if not os.path.isfile(examplesFile):
            log.warning(f'File "{examplesFile}" with trainExamples not found!')
            r = input("Continue? [y|n]")
            if r != "y":
                sys.exit()
        else:
            log.info("File with trainExamples found. Loading it...")
            with open(examplesFile, "rb") as f:
                self.trainExamplesHistory = Unpickler(f).load()
            log.info('Loading done!')

            # examples based on the model were already collected (loaded)
            self.skipFirstSelfPlay = True

"""##MAIN"""

# from google.colab import drive
# drive.mount('/content/drive')

import logging

# import coloredlogs

# from Coach import Coach
# from othello.OthelloGame import OthelloGame as Game
# from othello.pytorch.NNet import NNetWrapper as nn
# from utils import *

log = logging.getLogger(__name__)

# coloredlogs.install(level='INFO')  # Change this to DEBUG to see more info.


args2 = dotdict({
    'numIters': 100,
    'numEps': 50,              # Number of complete self-play games to simulate during a new iteration.
    'tempThreshold': 15,        #
    
    'updateThreshold': 0.55,     # During arena playoff, new neural net will be accepted if threshold or more of games are won.
    'maxlenOfQueue': 200000,    # Number of game examples to train the neural networks.
    'numMCTSSims': 90,          # Number of games moves for MCTS to simulate.
    'arenaCompare': 40,         # Number of games to play during arena play to determine if new net will be accepted.
    'cpuct': 1,

    'checkpoint': '/content/drive/MyDrive/Thesis',
    'load_model': False,
    'load_folder_file': ('/content/drive/MyDrive/Thesis','best.pth.tar'),
    'numItersForTrainExamplesHistory': 4,

})


def main():
    import sys
    
    sys.setrecursionlimit(10000)

    log.info('Loading %s...', ChessGame.__name__)
    g = ChessGame()

    log.info('Loading %s...', nn.__name__)
    nnet = NNetWrapper(g)

    if args2.load_model:
        log.info('Loading checkpoint "%s/%s"...', args2.load_folder_file)
        nnet.load_checkpoint(args2.load_folder_file[0], args2.load_folder_file[1])
    else:
        log.warning('Not loading a checkpoint!')

    log.info('Loading the Coach...')
    c = Coach(g, nnet, args2)

    # if args2.load_model:
    #     log.info("Loading 'trainExamples' from file...")
    #     c.loadTrainExamples()

    log.info('Starting the learning process 🎉')
    c.learn()


if __name__ == "__main__":
    main()

"""##TRASH

"""

import numpy as np

seed = np.arange(1,4097)

print(seed)

#add dirichlet noise to probability vector
noise = np.random.dirichlet(seed)

# #adding noise to probs
# temp = s + noise.flatten()

# #renormalize 
# prob_sum = float(sum(temp))
# s = np.array([x / prob_sum for x in temp])



print(noise[0])
print(noise.size)
print("aaa")
print(noise.flatten().size)
print(sum(noise.flatten()))

from psutil import virtual_memory


gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)



ram_gb = virtual_memory().total / 1e9
print('Your runtime has {:.1f} gigabytes of available RAM\n'.format(ram_gb))

if ram_gb < 20:
  print('Not using a high-RAM runtime')
else:
  print('You are using a high-RAM runtime!')

def func(a):
    a['0'] = 3


a = {}
a['0'] = 1

b = a

func(a)

print(a['0'])
print(b['0'])

# def is_valid(self,move,x_old,y_old):
#         piecetype, color = self.get_type(x_old,y_old)
#         x, y = int(move[1] - 1), self.chess_map_from_alpha_to_index[move[0]]
#         if (piecetype == 2):
#             if (self[x][y]*color > 0):
#                 return False
#             else:
#                 return True
#         elif (piecetype == 6):
#             if (self[x][y]*color > 0):
#                 return False
#             else:
#                 return True
#         elif (piecetype == 1):
#             if (y != y_old):
#                 if (self[x][y]*color < 0):
#                     return True
#                 else:
#                     return False
#             else:
#                 if (color == -1):
#                     if (y_old-y == 1):
#                         return (self[x][y] == 0)
#                     else:
#                         return (self[x][y] == 0 and self[x][y+1] == 0)
#                 else:
#                     if (y - y_old == 1):
#                         return (self[x][y] == 0)
#                     else:
#                         return (self[x][y] == 0 and self[x][y-1] == 0)
#         elif piecetype == 4:
#             if x != x_old:
#                 if x > x_old:
#                     for i in range(x_old+1,x):
#                         if self[i][y] != 0:
#                             return False
#                     return self[x][y] * color <= 0
#                 else:
#                     for i in range(x+1,x_old):
#                         if self[i][y] != 0:
#                             return False
#                     return self[x][y] * color <= 0   
#             else:
#                 if y > y_old:
#                     for i in range(y_old+1,y):
#                         if self[x][i] != 0:
#                             return False
#                     return self[x][y] * color <= 0
#                 else:
#                     for i in range(y+1,y_old):
#                         if self[x][i] != 0:
#                             return False
#                     return self[x][y] * color <= 0
#         elif piecetype == 3:
#             if x > x_old and y > y_old:
#                 for i in range(1, x - x_old):
#                     if self[x_old+i][y_old+i] != 0:
#                         return False
#             elif x > x_old and y < y_old:
#                 for i in range(1, x - x_old):
#                     if self[x_old+i][y_old-i] != 0:
#                         return False
#             elif x < x_old and y > y_old:
#                 for i in range(1, x_old - x):
#                     if self[x_old-i][y_old+i] != 0:
#                         return False
#             elif x < x_old and y < y_old:
#                 for i in range(1, x_old - x):
#                     if self[x_old-i][y_old-i] != 0:
#                         return False

#             return self[x][y] * color <= 0   

        
#         elif piecetype == 5:
#             #rook moves
#             if x != x_old:
#                 if x > x_old:
#                     for i in range(x_old+1,x):
#                         if self[i][y] != 0:
#                             return False
#                     return self[x][y] * color <= 0
#                 else:
#                     for i in range(x+1,x_old):
#                         if self[i][y] != 0:
#                             return False
#                     return self[x][y] * color <= 0   
#             else:
#                 if y > y_old:
#                     for i in range(y_old+1,y):
#                         if self[x][i] != 0:
#                             return False
#                     return self[x][y] * color <= 0
#                 else:
#                     for i in range(y+1,y_old):
#                         if self[x][i] != 0:
#                             return False
#                     return self[x][y] * color <= 0

#             #bishop moves
#             if x > x_old and y > y_old:
#                 for i in range(1, x - x_old):
#                     if self[x_old+i][y_old+i] != 0:
#                         return False
#             elif x > x_old and y < y_old:
#                 for i in range(1, x - x_old):
#                     if self[x_old+i][y_old-i] != 0:
#                         return False
#             elif x < x_old and y > y_old:
#                 for i in range(1, x_old - x):
#                     if self[x_old-i][y_old+i] != 0:
#                         return False
#             elif x < x_old and y < y_old:
#                 for i in range(1, x_old - x):
#                     if self[x_old-i][y_old-i] != 0:
#                         return False

#             return self[x][y] * color <= 0

"""# PIT

"""

import numpy as np


class RandomPlayer():
    def __init__(self, game):
        self.game = game

    def play(self, board):
        a = np.random.randint(self.game.getActionSize())
        valids = self.game.getValidMoves(board, 1)
        while valids[a]!=1:
            a = np.random.randint(self.game.getActionSize())
        return a


class HumanOthelloPlayer():
    def __init__(self, game):
        self.game = game

    def play(self, board):
        # display(board)
        valid = self.game.getValidMoves(board, 1)
        for i in range(len(valid)):
            if valid[i]:
                print("[", int(i/self.game.n), int(i%self.game.n), end="] ")
        while True:
            input_move = input()
            input_a = input_move.split(" ")
            if len(input_a) == 2:
                try:
                    x,y = [int(i) for i in input_a]
                    if ((0 <= x) and (x < self.game.n) and (0 <= y) and (y < self.game.n)) or \
                            ((x == self.game.n) and (y == 0)):
                        a = self.game.n * x + y if x != -1 else self.game.n ** 2
                        if valid[a]:
                            break
                except ValueError:
                    # Input needs to be an integer
                    'Invalid integer'
            print('Invalid move')
        return a


class GreedyOthelloPlayer():
    def __init__(self, game):
        self.game = game

    def play(self, board):
        valids = self.game.getValidMoves(board, 1)
        candidates = []
        for a in range(self.game.getActionSize()):
            if valids[a]==0:
                continue
            nextBoard, _ = self.game.getNextState(board, 1, a)
            score = self.game.getScore(nextBoard, 1)
            candidates += [(-score, a)]
        candidates.sort()
        return candidates[0][1]

"""
use this script to play any two agents against each other, or play manually with
any agent.
"""


g = chessGame()

# all players
rp = RandomPlayer(g).play
gp = GreedyOthelloPlayer(g).play
hp = HumanOthelloPlayer(g).play



# nnet players
n1 = NNet(g)
if mini_othello:
    n1.load_checkpoint('./pretrained_models/othello/pytorch/','6x100x25_best.pth.tar')
else:
    n1.load_checkpoint('./pretrained_models/othello/pytorch/','8x8_100checkpoints_best.pth.tar')
args1 = dotdict({'numMCTSSims': 50, 'cpuct':1.0})
mcts1 = MCTS(g, n1, args1)
n1p = lambda x: np.argmax(mcts1.getActionProb(x, temp=0))

if human_vs_cpu:
    player2 = hp
else:
    n2 = NNet(g)
    n2.load_checkpoint('./pretrained_models/othello/pytorch/', '8x8_100checkpoints_best.pth.tar')
    args2 = dotdict({'numMCTSSims': 50, 'cpuct': 1.0})
    mcts2 = MCTS(g, n2, args2)
    n2p = lambda x: np.argmax(mcts2.getActionProb(x, temp=0))

    player2 = n2p  # Player 2 is neural network if it's cpu vs cpu.

arena = Arena.Arena(n1p, player2, g, display=OthelloGame.display)

print(arena.playGames(2, verbose=True))